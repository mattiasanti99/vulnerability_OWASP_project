package library;

import io.restassured.module.jsv.JsonSchemaValidator;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;

import java.util.ArrayList;
import java.util.List;

import static io.restassured.RestAssured.*;
import static org.hamcrest.Matchers.*;
import static org.hamcrest.Matchers.equalTo;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class LibraryApplicationTests {
	String newBook = "{\n" +
			"        \"isbn\":765439,\n" +
			"        \"title\": \"La fabbrica di cioccolato\",\n" +
			"        \"author\": \"Roald Dahl\",\n" +
			"        \"genere\": \"Romanzo\",\n" +
			"        \"publicationYear\": 1964,\n" +
			"        \"avaiableCopies\": 10,\n" +
			"        \"price\": 1.0\n" +
			"}";

	String newBook_modified = "{\n" +
			"        \"isbn\":765439,\n" +
			"        \"title\": \"La fabbrica di cioccolata\",\n" +
			"        \"author\": \"Roald Dahl\",\n" +
			"        \"genere\": \"Fumetto\",\n" +
			"        \"publicationYear\": 1964,\n" +
			"        \"avaiableCopies\": 10,\n" +
			"        \"price\": 1.0\n" +
			"}";

	String newBook_modified_by_attacker = "{\n" +
			"        \"isbn\":765439,\n" +
			"        \"title\": \"La fabbrica di cioccolata\",\n" +
			"        \"author\": \"Roald Dahl\",\n" +
			"        \"genere\": \"Fumetto\",\n" +
			"        \"publicationYear\": 1964,\n" +
			"        \"avaiableCopies\": 0,\n" +
			"        \"price\": 0.0\n" +
			"}";

	String newUser = "{\n" +
			"        \"userName\": \"Marco\",\n" +
			"        \"password\": \"ciao\",\n" +
			"        \"role\": \"ROLE_USER\",\n" +
			"        \"rentedBook\": [],\n" +
			"        \"balance\": 1.0\n" +
			"}";

	String newUser_modified = "{\n" +
			"        \"userName\": \"Marco\",\n" +
			"        \"password\": \"ciao\",\n" +
			"        \"role\": \"ROLE_ADMIN\",\n" +
			"        \"rentedBook\": [],\n" +
			"        \"balance\": 1000.0\n" +
			"}";

	@LocalServerPort
	private int port;

	//I seguenti test riguardano il funzionamento dei metodi dell'applicazione

	@Test
	public void test_get_all_books() {
		given().port(port).when().
				get("/books").
				then().statusCode(200);
	}

	@Test
	public void test_getOneBook() {
		given().port(port).when().
				get("/books/{id}",1).
				then().statusCode(200);
	}

	@Test
	public void book_resource_returns_200_with_expected_ISBN() {

		given().port(port).when().
				get("/books/{id}", 1).
				then().
				statusCode(200).
				body("isbn", equalTo(123456));

	}

	@Test
	public void test_post_new_book(){
		//Test del corretto funzionamento del metodo post del nuovo libro
		given().port(port).contentType("application/json").accept("application/json")
				.body(newBook).
				when().
				post("/books").
				then().
				statusCode(201). //Mi aspetto un create 201
				body("isbn",equalTo(765439), //Mi aspetto il seguente body
				"title",equalTo("La fabbrica di cioccolato"),
				"author",equalTo("Roald Dahl"),
				"genere",equalTo("Romanzo"),
				"publicationYear",equalTo(1964),
				"avaiableCopies",equalTo(10));

	}

	@Test
	public void test_put_new_book(){

		//Creo un nuovo libro
		given().port(port).contentType("application/json").accept("application/json")
				.body(newBook).
				when().
				post("/books").
				then().
				statusCode(201);

		//Modifico il nuovo libro
		given().port(port).contentType("application/json").accept("application/json")
				.body(newBook_modified).
				when().
				put("/books/{id}",5).
				then().
				statusCode(201).  //Mi aspetto un create 201
				body("isbn",equalTo(765439),
				"title", equalTo("La fabbrica di cioccolata"),
				"genere", equalTo("Fumetto")); //Controllo che i dati siano stati modificati

	}

	@Test
	public void test_delete_book(){

		//Prima che venga effettuata la delete di un libro, l'utente con id 2 ha due libri
		given().port(port).when().
				get("/users/{id}/books",2).
				then().body("_embedded.bookList",hasSize(2));

		//Prima che venga effettuata la delete di un libro, l'utente con id 4 ha un libro
		given().port(port).when().
				get("/users/{id}/books",4).
				then().body("_embedded.bookList",hasSize(1));

		//Controllo che venga effettuata la delete del nuovo libro
		given().port(port).when().
				delete("/books/{id}",3).
				then().
				statusCode(200);

		//Controllo che effettuando la get del libro rimosso venga ritornato un errore 404
		given().port(port).when().
				get("/books/{id}",3).
				then().
				statusCode(404);

		//Mi aspetto che l'utente con id 2 abbia un solo libro
		given().port(port).when().
				get("/users/{id}/books",2).
				then().body("_embedded.bookList",hasSize(1));

		//Mi aspetto che l'utente con id 4 non abbia libri
		given().port(port).when().
				get("/users/{id}/books",4).
				then().body("_embedded.bookList",nullValue());
	}

	@Test
	public void test_getOneUser() {

		given().port(port).when().
				get("/users/{id}",2).
				then().statusCode(200);
	}

	@Test
	public void user_resource_returns_200_with_expected_username() {

		given().port(port).when().
				get("/users/{id}", 2).
				then().
				statusCode(200).
				body("userName", equalTo("Mattia99"));

	}

	@Test
	public void test_post_new_user(){
		//Test del corretto funzionamento del metodo post del nuovo libro
		given().port(port).contentType("application/json").accept("application/json")
				.body(newUser).
				when().
				post("/users").
				then().
				statusCode(201).body("userName",equalTo("Marco"), //Mi aspetto il seguente body
						"password",equalTo("ciao"),
						"role",equalTo("ROLE_USER")); //Mi aspetto un create 201

	}

	@Test
	public void test_get_user_books() {

		given().port(port).when().
				get("/users/{id}/books",2).
				then().statusCode(200);
	}

	@Test
	public void test_delete_user(){

		//Prima che venga effettuata la delete di un utente, il libro con id 3 è noleggiato da due utenti
		given().port(port).when().
				get("/books/{id}/users",3).
				then().body("_embedded.userList",hasSize(2));

		//Controllo che venga effettuata la delete del nuovo libro
		given().port(port).when().
				delete("/users/{id}",2).
				then().
				statusCode(200);

		//Controllo che effettuando la get del libro rimosso venga ritornato un errore 404
		given().port(port).when().
				get("/users/{id}",2).
				then().
				statusCode(404);

		//Mi aspetto che il libro con id 3 abbia un libro
		given().port(port).when().
				get("/books/{id}/users",3).
				then().body("_embedded.userList",hasSize(1));
	}

	//Validazione json schema di un libro
	@Test
	public void validate_json_schema_get_book_resource() {

		given().port(port).when().get("/books/{id}", 1).then().assertThat().body(JsonSchemaValidator.matchesJsonSchema("{\n" +
				"  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n" +
				"  \"type\": \"object\",\n" +
				"  \"properties\": {\n" +
				"    \"title\": {\n" +
				"      \"type\": \"string\"\n" +
				"    },\n" +
				"    \"author\": {\n" +
				"      \"type\": \"string\"\n" +
				"    },\n" +
				"    \"genere\": {\n" +
				"      \"type\": \"string\"\n" +
				"    },\n" +
				"    \"publicationYear\": {\n" +
				"      \"type\": \"integer\"\n" +
				"    },\n" +
				"    \"avaiableCopies\": {\n" +
				"      \"type\": \"integer\"\n" +
				"    },\n" +
				"    \"price\": {\n" +
				"      \"type\": \"number\"\n" +
				"    },\n" +
				"    \"users\": {\n" +
				"      \"type\": \"array\",\n" +
				"      \"items\": {}\n" +
				"    },\n" +
				"    \"id\": {\n" +
				"      \"type\": \"integer\"\n" +
				"    },\n" +
				"    \"isbn\": {\n" +
				"      \"type\": \"integer\"\n" +
				"    },\n" +
				"    \"_links\": {\n" +
				"      \"type\": \"object\",\n" +
				"      \"properties\": {\n" +
				"        \"self\": {\n" +
				"          \"type\": \"object\",\n" +
				"          \"properties\": {\n" +
				"            \"href\": {\n" +
				"              \"type\": \"string\"\n" +
				"            }\n" +
				"          },\n" +
				"          \"required\": [\n" +
				"            \"href\"\n" +
				"          ]\n" +
				"        },\n" +
				"        \"books\": {\n" +
				"          \"type\": \"object\",\n" +
				"          \"properties\": {\n" +
				"            \"href\": {\n" +
				"              \"type\": \"string\"\n" +
				"            }\n" +
				"          },\n" +
				"          \"required\": [\n" +
				"            \"href\"\n" +
				"          ]\n" +
				"        }\n" +
				"      },\n" +
				"      \"required\": [\n" +
				"        \"self\",\n" +
				"        \"books\"\n" +
				"      ]\n" +
				"    }\n" +
				"  },\n" +
				"  \"required\": [\n" +
				"    \"title\",\n" +
				"    \"author\",\n" +
				"    \"genere\",\n" +
				"    \"publicationYear\",\n" +
				"    \"avaiableCopies\",\n" +
				"    \"price\",\n" +
				"    \"users\",\n" +
				"    \"id\",\n" +
				"    \"isbn\",\n" +
				"    \"_links\"\n" +
				"  ]\n" +
				"}"));

	}

	//Validazione json schema di un utente, aspettandomi che la password non sia visibile
	@Test
	public void validate_json_schema_get_user_resource() {

		given().port(port).when().get("/users/{id}", 2).then().assertThat().body(JsonSchemaValidator.matchesJsonSchema("{\n" +
				"  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n" +
				"  \"type\": \"object\",\n" +
				"  \"properties\": {\n" +
				"    \"password\": {\n" +
				"      \"type\": \"string\"\n" +
				"    },\n" +
				"    \"role\": {\n" +
				"      \"type\": \"string\"\n" +
				"    },\n" +
				"    \"balance\": {\n" +
				"      \"type\": \"number\"\n" +
				"    },\n" +
				"    \"id\": {\n" +
				"      \"type\": \"integer\"\n" +
				"    },\n" +
				"    \"rentedBook\": {\n" +
				"      \"type\": \"array\",\n" +
				"      \"items\": {}\n" +
				"    },\n" +
				"    \"userName\": {\n" +
				"      \"type\": \"string\"\n" +
				"    },\n" +
				"    \"_links\": {\n" +
				"      \"type\": \"object\",\n" +
				"      \"properties\": {\n" +
				"        \"user_books\": {\n" +
				"          \"type\": \"object\",\n" +
				"          \"properties\": {\n" +
				"            \"href\": {\n" +
				"              \"type\": \"string\"\n" +
				"            }\n" +
				"          },\n" +
				"          \"required\": [\n" +
				"            \"href\"\n" +
				"          ]\n" +
				"        },\n" +
				"        \"self\": {\n" +
				"          \"type\": \"object\",\n" +
				"          \"properties\": {\n" +
				"            \"href\": {\n" +
				"              \"type\": \"string\"\n" +
				"            }\n" +
				"          },\n" +
				"          \"required\": [\n" +
				"            \"href\"\n" +
				"          ]\n" +
				"        }\n" +
				"      },\n" +
				"      \"required\": [\n" +
				"        \"user_books\",\n" +
				"        \"self\"\n" +
				"      ]\n" +
				"    }\n" +
				"  },\n" +
				"  \"required\": [\n" +
				"    \"password\",\n" +
				"    \"role\",\n" +
				"    \"balance\",\n" +
				"    \"id\",\n" +
				"    \"rentedBook\",\n" +
				"    \"userName\",\n" +
				"    \"_links\"\n" +
				"  ]\n" +
				"}"));

	}

	//I prossimi test riguarderanno le vulnerabilità dell'applicazione

	//Test sulla visualizzazione dei dati sensibili dell'utente, ossia la password e il ruolo
	@Test
	public void test_sensible_data_user() {

		given().port(port).when().
				get("/users/{id}",2).
				then().statusCode(200).body("password",equalTo(null),
						"role", equalTo(null)); //Mi aspetto che non vengano visualizzati tali dati
	}

	//Test sulla modifica dei dati di un utente
	@Test
	public void test_put_new_data_user(){

		//Aggiungo un nuovo utente
		given().port(port).contentType("application/json").accept("application/json")
				.body(newUser).
				when().
				post("/users").
				then().
				statusCode(201);

		given().port(port).contentType("application/json").accept("application/json")
				.body(newUser_modified).
				when().
				put("/users/{id}",5).
				then().
				statusCode(201).body("role",equalTo("ROLE_USER"),
						"balance",equalTo(1.0)); //Mi aspetto che non venga alterato ne il ruolo ne il saldo


	}

	//Test broken level authorization, per verificare che un attaccante possa accedere agli altri utenti, manipolando gli id
	@Test
	public void test_broken_level_authorization() {
		int count = 0; //Contatore degli account trovati
		for(int id = 0; id <= 10;id++){ //Controllo solo i primi 10 endpoints
			Integer statusCode = given().port(port).when().get("/users/{id}",id).getStatusCode();
			if(statusCode == 200) //Se lo status code è 200 significa che si ha accesso a quei dati
				count++;

		}

		if(count > 1) //Se si ha accesso a più profili
			System.out.println("TEST FALLITO perchè si ha accesso a " + count + " profili");
		else
			System.out.println("TEST RIUSCITO");
	}

	//Test sul numero di richieste accettate simultaneamente
	@Test
	public void test_concurrent_requests_with_threads(){
		final int NUMBER_OF_THREADS = 100;
		List<Request_thread> threads = new ArrayList<>(); //Creo una lista di thread

		for(int i = 0; i < NUMBER_OF_THREADS; i++){ //Istanzio i thread
			threads.add(new Request_thread(port,i));
		}

		for(Request_thread thread: threads) //Faccio partire i thread
			thread.start();

		given().port(port).when().get("/books");

	}
}
